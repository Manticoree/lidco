"""Rules management for LIDCO projects."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

# Default rules template for new projects
_DEFAULT_RULES_TEMPLATE = """\
# {project_name} - Project Rules

> This file was generated by `lidco init`. LIDCO reads it on every session start
> to understand your project conventions. Edit freely or add rules with `/rules add`.

## Code Style

- Follow the existing code style of the project
- Use consistent naming conventions
- Keep functions small and focused

## Project Structure

- Organize code by feature/domain
- Keep related files close together

## Git Workflow

- Write clear, descriptive commit messages
- Keep commits atomic and focused

## Testing

- Write tests for new functionality
- Maintain existing test coverage

---

*Add your own rules below this line:*

"""


@dataclass(frozen=True)
class Rule:
    """A single rule entry."""

    title: str
    content: str


class RulesManager:
    """Manages project rules stored in LIDCO.md and .lidco/rules/."""

    def __init__(self, project_dir: Path | None = None) -> None:
        self.project_dir = project_dir or Path.cwd()
        self.rules_file = self.project_dir / "LIDCO.md"
        self.rules_dir = self.project_dir / ".lidco" / "rules"

    def has_rules_file(self) -> bool:
        """Check if the main rules file exists."""
        return self.rules_file.exists()

    def init_rules(self, project_name: str | None = None) -> Path:
        """Create the default LIDCO.md rules file.

        Returns the path to the created file.
        Raises FileExistsError if the file already exists.
        """
        if self.rules_file.exists():
            raise FileExistsError(f"{self.rules_file} already exists")

        name = project_name or self.project_dir.name
        content = _DEFAULT_RULES_TEMPLATE.format(project_name=name)
        self.rules_file.write_text(content, encoding="utf-8")

        # Ensure .lidco/rules/ directory exists for additional rule files
        self.rules_dir.mkdir(parents=True, exist_ok=True)

        return self.rules_file

    def add_rule(self, title: str, content: str) -> None:
        """Append a new rule to LIDCO.md.

        If LIDCO.md doesn't exist, creates it first with defaults.
        """
        if not self.rules_file.exists():
            self.init_rules()

        existing = self.rules_file.read_text(encoding="utf-8")
        rule_block = f"\n## {title}\n\n{content}\n"
        updated = existing.rstrip() + "\n" + rule_block
        self.rules_file.write_text(updated, encoding="utf-8")

    def add_rule_file(self, name: str, content: str) -> Path:
        """Create a separate rule file in .lidco/rules/.

        Returns the path to the created file.
        """
        self.rules_dir.mkdir(parents=True, exist_ok=True)

        # Sanitize filename
        safe_name = name.replace(" ", "-").lower()
        if not safe_name.endswith(".md"):
            safe_name += ".md"

        rule_path = self.rules_dir / safe_name
        rule_path.write_text(f"# {name}\n\n{content}\n", encoding="utf-8")
        return rule_path

    def list_rules(self) -> list[Rule]:
        """List all rules from LIDCO.md (parsed by ## headings)."""
        if not self.rules_file.exists():
            return []

        text = self.rules_file.read_text(encoding="utf-8")
        return self._parse_rules(text)

    def list_rule_files(self) -> list[Path]:
        """List all .md files in .lidco/rules/."""
        if not self.rules_dir.is_dir():
            return []
        return sorted(self.rules_dir.glob("*.md"))

    def get_all_rules_text(self) -> str:
        """Get full text of all rules (LIDCO.md + rule files)."""
        parts: list[str] = []

        if self.rules_file.exists():
            try:
                parts.append(self.rules_file.read_text(encoding="utf-8"))
            except OSError:
                pass

        for rule_file in self.list_rule_files():
            try:
                content = rule_file.read_text(encoding="utf-8")
                parts.append(f"\n---\n\n{content}")
            except OSError:
                continue

        return "\n".join(parts)

    @staticmethod
    def _parse_rules(text: str) -> list[Rule]:
        """Parse ## headings from markdown into Rule objects."""
        rules: list[Rule] = []
        current_title = ""
        current_lines: list[str] = []

        for line in text.splitlines():
            if line.startswith("## "):
                if current_title:
                    rules.append(Rule(
                        title=current_title,
                        content="\n".join(current_lines).strip(),
                    ))
                current_title = line[3:].strip()
                current_lines = []
            elif current_title:
                current_lines.append(line)

        if current_title:
            rules.append(Rule(
                title=current_title,
                content="\n".join(current_lines).strip(),
            ))

        return rules
